
[{"content":"","date":"2 February 2026","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"\rWhile trying to build my relay computer I became frustrated at the lack of available software to model Relay Logic. Other simulators out there were either VERY expesive or could not model relay logic in a useable way. So I did what anyone else would do in my position - I spent close to six months writing my own!!\nThe result is RelaySim and I hope others will find it useful and help contribute to it\u0026rsquo;s ongoing development.\n","date":"2 February 2026","externalUrl":null,"permalink":"/posts/relaysim/","section":"Posts","summary":"","title":"Relay Simulator","type":"posts"},{"content":"","date":"2 February 2026","externalUrl":null,"permalink":"/tags/relaysim/","section":"Tags","summary":"","title":"RelaySim","type":"tags"},{"content":"Here\u0026rsquo;s a brief video overview of my Relay simulator in action. IT covers all the main components and features of the Relay Sim.\nhttps://youtu.be/Usn1yL1To4o\nHere\u0026rsquo;s it in action running a basic program on my simulated 12-bit relay computer.\nhttps://youtu.be/WexWQT18NUc\n","date":"2 February 2026","externalUrl":null,"permalink":"/posts/relaysim/demo/","section":"Posts","summary":"","title":"RelaySim Demo","type":"posts"},{"content":"","date":"2 February 2026","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"Welcome to ChickFamily.net\nThis site will be collection of personal engineering and computing projects. system architecture — often using unconventional methods.\nFeatured projects include Y.A.R.P., a fully relay-based processor built from electromechanical components, and a custom Relay Simulator used to design and test complex logic circuits in software. If you\u0026rsquo;re interested in computer architecture, digital logic, or building systems from first principles, you’re in the right place.\n\u0026ldquo;Exploring computer architecture from first principles — one relay at a time.\u0026rdquo;\n","date":"2 February 2026","externalUrl":null,"permalink":"/","section":"Welcome!","summary":"","title":"Welcome!","type":"page"},{"content":"","date":"3 January 2026","externalUrl":null,"permalink":"/tags/alu/","section":"Tags","summary":"","title":"ALU","type":"tags"},{"content":"The ALU_A Arithmetic card will without doubt be one of the busiest and most complex cards I\u0026rsquo;ll have to build. The goal is to design a card that can support the following operations:\nAddition B+C Subtraction B-C, Increment B Increment C Decrement B Decrement C The diagram below shows the outline of the ALU_A logic. I have only included the logic for bits 0,1 and 11 for simplicity.\n!\rThere are three groups of relays to be controlled and a logic line.\nThe Green relays control If the B-Bus or C-Bus is connected to the first input of each adder. The Red relays control if the C-Bus OR if the static value of 1 (0000 000 0001) is connected to the second input of each adder. The Blue relays are used to gate the result of the adder operation onto the Data Bus. The final control line is the Orange ADD/SUB control line. Addition\r#\rAddition is fairly straight forward. To add B+C the B-Bus is connected to the adder via the Green relays The C-Bus is connected the adder via the Red Relays. The Orange ADD/SUB Line is a 0 signalling an addition operation.\nI\u0026rsquo;ll explain more about what the XOR gates do later in the article - but for now think of the XOR gates as a switchable Inverter. In the case of our addition this inverter is disabled and the B-BUS passes straight through XOR gates. Finally you will also notice that the carry in to the first full adder will also be a 0 because the ADD/SUB line is also 0.\nThe Adder\u0026rsquo;s will then compute B+C and the result will be gated onto the data bus via the BLUE gating relays.\nThe state of last adders carry out will be stored in the CY condition Register.\nIncrement B\r#\rThe GREEN Relays will connect the B-BUS to the adders in the same way as for addition. The ADD/SUB line will also be a 0 as before. To Increment B we have to switch the Red relay\u0026rsquo;s over to the static value of 1 (0000 0000 0001). So we are now adding B+1 - Incrementing B.\nIncrement C\r#\rTo Increment C we switch the Green Relays over to connect to the first input of the adder to the C-BUS. We also have the RED relays switched to the static value of 1 (0000 0000 0001). So we now get C+1 - Incrementing C.\nSubtraction\r#\rSubtraction can be performed by adding the Two\u0026rsquo;s compliment of one number to the second number and adding 1. For a more detailed explanation of two\u0026rsquo;s compliment I\u0026rsquo;d suggest that you watch this video.\nTo convert the first number into the adder we have to first make it a two\u0026rsquo;s compliment of itself, basically inverting it. so with the ADD/SUB line now 1 the XOR Gates will now act as an inverter. For reference here\u0026rsquo;s the Truth table for an XOR gate:\nA B X 0 0 0 0 1 1 1 0 1 1 1 0 Here we can see that if the A input of the XOR gate is driven by the ADD/SUB control line we get this switchable inverter effect between the B input and the X output.\nThe next thing we have to do is add 1, this is easy so we just feed the carry in of the first inverter with the ADD/SUB line.\nThe last thing we need it to know if the result is negative. This is accomplished by the Inverter and the AND Gate. If the carry out bit from the last adder is 0 AND it\u0026rsquo;s a subtraction operation the SN (Sign) bit will be set in the condition register.\nDecrement B and C\r#\rThese operations are identical to the Increment operation when it comes to selecting what data feeds the input of the adders.\nControl Logic\r#\rSo there we are, six mathematical functions using a single adder block!\nWe can describe a logic table of all the inputs and the functions:\nB/C Relays (Green) C / 1 Relays (Red) ADD/SUB (Orange) Function 0 0 0 B+C Addition 0 0 1 B-C Subtraction 0 1 0 Increment B 0 1 1 Decrement B 1 0 0 UNUSED 1 0 1 UNUSED 1 1 0 Increment C 1 1 1 Decrement C Practical considerations\r#\rThis will take a lot of relays and board space. My current plan will be to split the board into a base card and a daughter board. The base card will manage the control logic, Input selection, XOR \u0026lsquo;inverter\u0026rsquo;s\u0026rsquo; and gating back to the data bus. The daughter board will be dedicated to the Adder logic, it will only have the two selected bus inputs, the result output, the first carry in and the last carry out. This will make it far easier to debug the ALU as a whole if I can split it operations over the two cards .\n","date":"3 January 2026","externalUrl":null,"permalink":"/posts/yarp/alu_a-overview/","section":"Posts","summary":"","title":"ALU_A Arithmetic Unit","type":"posts"},{"content":"","date":"3 January 2026","externalUrl":null,"permalink":"/tags/alu-arithmetic/","section":"Tags","summary":"","title":"ALU-Arithmetic","type":"tags"},{"content":"Documentation regarding the design and build of my own 12-bit Relay Computer.\n","date":"3 January 2026","externalUrl":null,"permalink":"/posts/yarp/","section":"Posts","summary":"","title":"Y.A.R.P Relay Computer","type":"posts"},{"content":"The ALU will eventually consist of a number of cards divided into three groups.\nALU-Arithmetic (ALU_A)\r#\rThis is the arithmetic card, It supports B + C, B - C, INCREMENT B and INCREMENT C.\nThis is probably the biggest card so far, so it has been split between a main card and a daughter board. The Main card holds the data latches and control logic, while the daughter card holds the full adder\u0026rsquo;s.\nI will be building a \u0026lsquo;Zuse\u0026rsquo; adder. Developed by Konrad Zuse in the 1930\u0026rsquo;s it\u0026rsquo;s benefit is it is faster as it doesn\u0026rsquo;t ripple across each adder clock.\nMy current design will be to have the input stages on the main card and the actual adder itself on a daughter card. I\u0026rsquo;m fairly confident around the support logic, but if If the adder unit itself needs additional iterations I can simply swap that section out.\nALU-Logic (ALU_L)\r#\rThere are 7 main logic gates. AND, OR, NOT, NAND, NOR, XOR and XNOR. For my relay computer I wanted to implement all of these.\nThe ALU-L cards provide all the logical functions. Rather than design separate cards for each set of logical functions, I realized it would be far easier (and cheeper) to have identical ALU_L main cards which control the gating and selection logic, with smaller daughter cards to support the actual logical functions.\nThefore my relay computer has two ALU_L cards, splitting all the logical functios between them.\nEach card supports four logical functions each - via the daughter cards.\nCard 1 supports AND, OR, XOR, NOT_B\nCard 2 supports NOR, XNOR, NAND, NOT_C\nEach daughter card supports two bits of data, D0 and D1, D2 and D3 etc. but they are all identical.\nWe only have to support 7 logical gates but I had enough capacity to add a NOT_B and a NOT_C. So I have 8 selectible logical functions over the two ALU_L cards.\nIn the photograph you can see the underneath the daughter cards are the gating relays that transfer the logical result to the data bus when required.\nALU_Shift (ALU_S)\r#\rThis is the Shift register card. It supports shifting or rotating left or right from Register B or Register C as the source.\nRotating left or right may never really be used, but for the cost of one relay it seemed a waste not to include the facility.\n","date":"2 January 2026","externalUrl":null,"permalink":"/posts/yarp/alu-overview/","section":"Posts","summary":"","title":"ALU Overview","type":"posts"},{"content":"","date":"2 January 2026","externalUrl":null,"permalink":"/tags/alu-logic/","section":"Tags","summary":"","title":"ALU-Logic","type":"tags"},{"content":"","date":"2 January 2026","externalUrl":null,"permalink":"/tags/overview/","section":"Tags","summary":"","title":"Overview","type":"tags"},{"content":"The most important question you may be asking is\u0026hellip;\n\u0026lsquo;Why is it called YARP?\u0026rsquo;\nFirstly, I believe every project should have a good acronym. Some of the best suggestions from https://acronymify.com/ gave me\u0026hellip;\nTELETYPE - TwELvE biT relaY comPutEr - This was a serious contender. ENCRYPT - ENhanCed RelaY comPuTer - another possibility. REACT - RElAy CompuTer - I think that\u0026rsquo;s already taken. TAROT - ulTimAte Relay cOmpuTer - a bit too dark arts for me. Secondly, One of my favourite films is \u0026lsquo;Hot Fuzz\u0026rsquo;, so the decision was easy.\nYARP - Yet Another Relay comPuter\nMaybe if I build a another version I could call it\nNARP - Not Another Relay comPuter\nI\u0026rsquo;ll get my coat..\n","date":"2 January 2026","externalUrl":null,"permalink":"/posts/yarp/why-is-it-called-yarp/","section":"Posts","summary":"","title":"Why is it called YARP?","type":"posts"},{"content":"\rOverview\r#\rFirst if we take a look at the Relay computer designed by Harry Porter (from now on I\u0026rsquo;ll refer to it as the HP Design or HP Architecture).\nHP Design\rIt\u0026rsquo;s an excellent, elegant design. But in studying it and the subsequent refinements made by Paul Law and DipDot (https://www.youtube.com/@dipdoting) I started to wonder where else I could take it, and what I could add.\nSo let me introduce YARP - Yet Another Relay comPuter!\n12-Bit YARP Design\rSpecification\r#\rThe core of my design is based on the \u0026lsquo;HP architecture\u0026rsquo; - if it ain\u0026rsquo;t broke don\u0026rsquo;t fix it! But I decided to make some fundamental changes.\n12-Bits\r#\rThe computer is 12-bits. 12-bit Address bus, 12-bit Data bus and 12-bit ALU.\n12-bit computers have their place in History. Besides who could not resist building a computer with 12 binary digits, or three nibbles (a \u0026rsquo;tribble\u0026rsquo;)! Mr Spock would be proud!\nUsing a 12-bit data and address bus has given me the ability to enhance some of it\u0026rsquo;s core features and the room to extend it\u0026rsquo;s capabilities in the future. I settled on 12-bits as I thought is was the sweetspot (for me).\nI can play with large\u0026rsquo;ish numbers (4095 max). I can have a much larger instruction set. I\u0026rsquo;d never need more that 4096 \u0026lsquo;bytes\u0026rsquo; of memory in reality - a 16 bit address range would be overkill as the majority of memory space would never be used. I don\u0026rsquo;t have to worry about High and Low register pairs such as the X and Y data registers in the HP architecture which becomes the XY address register. NOTE: I\u0026rsquo;ll often refer to storing Bytes or grabbing the next Byte. Unless otherwise noted I\u0026rsquo;ll always be referring to a 12-Bit \u0026lsquo;Byte\u0026rsquo;. If such a thing exits!\nAs for the number of relay\u0026rsquo;s used - it will take more relays - but I don\u0026rsquo;t think the amount will be as significant as I first thought as I am increasing the data-bus but reducing the address bus across the design.\nALU Enhancements\r#\rWith the increase in Instruction set, I\u0026rsquo;ve also been able to increase the capabilities of the ALU. The ALU is now split into three separate functional areas (ALU_A, ALU_L and ALU_S) each having it\u0026rsquo;s own or multiple cards.\nALU_A (Arithmetic) will be able to add, subtract, increment and decrement all in hardware. It will support B+C, B-C, INC_B, INC_C, DEC_B and DEC_C. ALU_L (Logic) will support all common logic gates ADD, OR, NAND, NOR, XOR, XNOR, NOT_B and NOT_C. ALU_S (Shift) will support Shift Left B, Shift Left C, Rotate Left B, Rotate Left C, and the same shifting to the Right. Shift Right B, Shift Right C, Rotate Right B, Rotate Right C. Memory Stack and Interrupts\r#\rI would like to implement an 8 byte stack. This will be able to hold the contents of ALL working registers and program counter. The instruction set will support PUSH, POP and PEEK to any register or the program counter.\nI also have an Interrupt handling system planned. Servicing an interrupt will be achieved by switching between two different FETCH-NEXT cycles. The decision on what FETCH-NEXT cycle to use will be decided by the state of the INTERRUPT and INTERRUPT ENABLE lines.\nIn order to understand how the INTERRUPT FETCH-NEXT cycle works I should first explain how a normal FETCH-NEXT cycle works.\nYou Read the memory at the address stored in the PC, this is loaded into the instruction register. While the PC is selected and the current address is on the address bus the Incrementor reads the address, adds one then stores it in the INC register. This new address (PC+1) that is stored in the INC register is then stored back in the PC. If an Interrupt is triggered the INTERRUPT FETCH-NEXT cycle will be enabled. This will\u0026hellip;\nDisable further interrupts by disabling the INT_EN line. This ensures you cannot interrupt an interrupt. PUSHes the current PC onto the Stack. Sets the PC to a predefined address (tbd). I might store this in it\u0026rsquo;s own interrupt address register, or hard code a default address - not sure yet). Continue loading the Instruction Register and incrementing the PC in the normal way as above (this time from the Interrupt address) completing the Fetch-Next cycle. With this complete we are now running the interrupt service routine. The interrupt program code will\u0026hellip;\nPUSH any other required registers onto the stack. If the Interrupt code only requires registers B and C then they are the only ones that need to be PUSH\u0026rsquo;ed. Execute the interrupt code. To return back to the main program the interrupt service routine will\u0026hellip;\nPOP the working registers back to their original values. POP the PC back to it\u0026rsquo;s original value. Re-enable the INT_EN line. The main program will then resume where it left off.\nThe Stack will be a large sub project on it\u0026rsquo;s own. I\u0026rsquo;ll need 8 memory locations, each one selected by a 3-8 line decoder.\nEach PUSH will increment a stack pointer then load the value on the data bus into that current location. Each PULL sets the value of the current stack location onto the data bus, then will decrement the stack pointer. Two condition flags Stack Empty, and Stack Overflow will be able to be tested as a JUMP condition in a similar way to SN, CY, EZ and NZ. I am toying with the idea of having a switch so that I can choose if a Stack Overflow will HALT the computer. Increase the number of working registers\r#\rMy design will have more working registers than the \u0026lsquo;HP architecture\u0026rsquo;. I am still undecided about if these additional registers will be Data only such as the A,B,C or D registers or data and address registers such as X or Y. I might add some of each type.\nDedicated I/O Instructions\r#\rI will have a dedicated I/O address bus (which will probably only be 4 bit - supporting 15 peripherals. To Read from an I/O address you will first set the I/O Address, then Read or Write.\nOnce the I/O address it set subsequent reads or writes will be to the same address.\nThe I/O interface has the ability to set the computer to WAIT until the I/O hardware is ready to return data. This will freeze the clock until the wait is cleared.\nIOSET xxxx,dddd - Sets the IO address to use. IOWRI nnnnnnnn - Writes an 8-bit value directly to the address set in IOSET. IORD aaaa,dddd - Read IO at address aaaa and stores in register dddd. IOWR ssss,aaaa - Write the value stored in register ssss to IO address. Side projects\r#\rNo project would be complete without random side projects to burn the hours away. I am keeping to this tradition!\nBuilding some form of paper tape reader / writer (for 12-bit data!) A \u0026lsquo;ROM cartridge\u0026rsquo; system. that I can use to store a bootloader. Custom case to make it \u0026lsquo;portable\u0026rsquo; (but I\u0026rsquo;ll settle for luggable!). I want to be able to take this to maker fair\u0026rsquo;s and let people interact with it as much as possible. I\u0026rsquo;d like to go with a slightly WW2 / steampunk look. Bakelight and Brass! A true Random Number Generator. I\u0026rsquo;m imagining a marble drop machine with 12 channels at the bottom, when you ask for a random number it reads the colour of the balls (black or white) before re circulating them back up to be dropped again. Loud, Madness but fun! Human Clock. The main computer clock will be similar to other designs, however I want to build a large box with a hand wheel, where someone can literally \u0026lsquo;crank\u0026rsquo; the clock pulses into the machine. Great for interactive Demo\u0026rsquo;s etc! Constraints\r#\rEverything to do with the core computing functions of the machine has to be done by relay\u0026rsquo;s (except Memory - see below). Diodes can be used to stop back-feeding signals but at a minimum. LED\u0026rsquo;s are allowed for monitoring purposes on the card\u0026rsquo;s - the more blinkin\u0026rsquo; lights the better! It\u0026rsquo;s not to say that my machine will be silicon free! - far from\u0026hellip;\nA RAM chip will be used for main memory. However I want to integrate some other discreet memory devices along side (Relay RAM or Capacitor RAM) just to prove it could work if I had enough time or budget to build a 4096 * 12 bit memory storage by hand! This I feel is an honourable compromise. If I\u0026rsquo;m going to cheat compromise on the RAM - I might as well make the most of it! So my plan will be to use a microcontroller (with wifi) for the RAM. In normal operation the microcontroller will function as basic RAM - implemented as many others have done. However it will also give me the ability to write a debugging interface. The goal will be to view, edit, load and save the memory from a terminal browser or telnet session etc.\nA Diagnostic card is also planned that will be able to view the busses and manipulate the key control lines. Based on a wifi Enabled microcontroller. Again useful for diagnostics as it\u0026rsquo;s being built but would also serve another purpose as the ultimate goal would be to put this computer \u0026lsquo;on the net\u0026rsquo; so people could write their own programs and run them remotely!\nFinally no electronics project would be complete without a \u0026lsquo;555\u0026rsquo; timer! So their will be a second clock source built around one of these - just to annoy the purists! Seriously, this will serve a dual purpose, the relay\u0026rsquo;s that drive the clock will have to cope with a lot of cycles and I am worried about wearing these out. Again I feel having and using a digital clock is acceptable providing that a 100% Relay based clock is built alongside it and we can swap between the two. The other reason is that I will be able to control the 555 timers speed via a variable resistor, this will make it handy for debugging etc. where I can really slow the clock down if I need to.\n","date":"1 January 2026","externalUrl":null,"permalink":"/posts/yarp/yarp-yet-another-relay-computer/","section":"Posts","summary":"","title":"YARP Overview","type":"posts"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]